/*
这道题主要考察了重载、内联函数

- 在编译期处理哪个函数签名最匹配
- 重载：同名但是不同参数列表（返回类型不参与、形参顶层的const不参与）
    - 编译器内部对重载的解析：
        - 1. 候选集：找到所有同名函数;
        - 2. 可行集：能通过隐式转换把实参转换为形参的函数
        - 3. 最佳可行函数：比较每个参数的转换“优劣”，选整体更优的那个；若无唯一更优 => 二义性报错
    - 优劣排序：
        - 1. 精准匹配：类型完全相同、或仅限底层cv的调整
        - 2. 提升：
            - a. 提升整型：bool/char/signed char/unsigned char/short => int（或 unsigned int）
            - b. 提升浮点：float => double
        - 3. 转换：int <=> float、double => float、double => int、unsigned <=> signed、派生 => 基类等
    - 消歧修正：
        - 1. 显式类型转换：调用 (float)i 等
        - 2. 添加后缀字面量：如 3.0f （有点像TS里的 i as float )

- 如果在需要将函数体写在头文件中，而且这个头文件被多次导入，那么由于 include 会相当于嵌入代码会导致在链接期头文件中函数体被多次定义
- 为了处理 ODR（One Definition Rule）：
    - !Important: 最推荐的做法就是在功能头文件中写函数声明，将功能函数的函数体在单独的 cpp 中实现，那么其他地方要使用的时候只需要导入这个功能函数的声明头文件、相当于使用的是同一个
    - 1. 头文件static：（有点像闭包、类里面的静态私有函数）只能在定义其文件内部使用，控制了作用域，各 TU 各有一份函数体；可避免重定义，但可能导致重复代码
    // - 2. 宏 #define：无类型/作用域检查，不要用来替代函数；inline 是更安全的宏替代品
    // - 3. constexpr：隐含 inline；要求函数在编译期可求值（满足限制）
    - 4. inline 内联：编译器会将内联函数的代码直接插入到调用点，避免函数调用的压栈、跳转、返回等操作（比如 DFS 不当常常会导致爆栈，但是递归也没法用inline会导致代码膨胀的问题，可以通过自己维护栈显式使用来优化）

详细内容看 Ex9 文件夹
*/